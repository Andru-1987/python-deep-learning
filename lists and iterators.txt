iterators and generators


list=["hello","world"]

for word in list:
    print(word)

for letter in "hello world":
    print(letter)

for i in range(100):
    print (i)

list,string, dictionaries file connections are iterable

an object with an associated iter() method

iterator and a next() method

word="around the world in 80 days"
it=iter(word)
for i in np.arange(0,len(word)):
    print(next(it))


word="around the world in 80 days"
it=iter(word)
   
print(*it)  

once you have iterated over the items they are depleted

>>iterating over a dictionary

dict={'firstName':'david','lastName':'nishimoto'}

for key,value in dict.items():
    print(key,value)

>>opening a file

file=open('file.txt')
it=iter(file)
print(next(it))

>>Sample

# Create a list of strings: flash
flash = ['jay garrick', 'barry allen', 'wally west', 'bart allen']

# Print each list item in flash using a for loop

for item in flash:
    print(item)

# Create an iterator for flash: superhero
it=iter(flash)

# Print each item from the iterator
print(next(it))
print(next(it))
print(next(it))
print(next(it))

>>>Sample

# Create an iterator for range(3): small_value
small_value = iter(range(3))

# Print the values in small_value
print(next(small_value))
print(next(small_value))
print(next(small_value))

# Loop over range(3) and print the values
for num in range(3):
    print(num)

# Create an iterator for range(10 ** 100): googol
googol = iter(range(10 ** 100))

# Print the first 5 values from googol
print(next(googol))
print(next(googol))
print(next(googol))
print(next(googol))
print(next(googol))

>>Sample

# Create a range object: values
values = range(10,21)

# Print the range object
print(values)

# Create a list of integers: values_list
values_list = list(values)

# Print values_list
print(values_list)

# Get the sum of values: values_sum
values_sum = sum(values_list)
# Print values_sum
print(values_sum)


>>Enumerate and zip

enumerate returns an enumerator object

avengers =['hawkeye','iron man','thor','quicksilver']

e=enumerate(avengers)
print(type(e))

#e_list=list(e)
#print(e_list)

for index,value in enumerate(avengers):
    print(index,value)
    
for index,value in enumerate(avengers, start=10):
    print(index,value)   


>>>Sample

# Create a list of strings: mutants
mutants = ['charles xavier', 
            'bobby drake', 
            'kurt wagner', 
            'max eisenhardt', 
            'kitty pryde']

# Create a list of tuples: mutant_list
mutant_list = list(enumerate(mutants))

# Print the list of tuples
print(mutant_list)

# Unpack and print the tuple pairs
for index1, value1 in enumerate(mutants):
    print(index1, value1)

# Change the start index
for index2, value2 in enumerate(mutants, start=1):
    print(index2, value2)


>>>Sample zip

Printing just a zip object will not return the values unless you unpack it first. In this exercise, you will explore this for yourself.


>>>Sample

# Create a list of tuples: mutant_data
mutant_data = list(zip(mutants, aliases, powers))


# Print the list of tuples
print(mutant_data)

# Create a zip object using the three lists: mutant_zip
mutant_zip = zip(mutants,aliases,powers)

# Print the zip object
print(mutant_zip)

# Unpack the zip object and print the tuple values
for value1,value2,value3 in mutant_zip:
    print(value1, value2, value3)


>>>Sample using splat

# Create a zip object from mutants and powers: z1
z1 = zip(mutants,powers)

# Print the tuples in z1 by unpacking with *
print(*z1)

# Re-create a zip object from mutants and powers: z1
z1 = zip(mutants,powers)

# 'Unzip' the tuples in z1 by unpacking with * and zip(): result1, result2
result1, result2 = zip(*z1)

# Check if unpacked tuples are equivalent to original tuples
print(result1 == mutants)
print(result2 == powers)


>>Using iterators to load large files into memory

1. Loading data in chunks
2. There can be too much data to hold in memory

read_csv()
chunk_size


import pandas as pd

total=0

for chunk in pd.read_csv('data.csv', chunksize=1000):
	result.append(sum(chunk['x']))

	total+=sum(chunk['x'])


>>>Sample

# Initialize an empty dictionary: counts_dict
counts_dict={}

# Iterate over the file chunk by chunk
for chunk in pd.read_csv('tweets.csv', chunksize=10):

    # Iterate over the column in DataFrame
    for entry in chunk['lang']:
        if entry in counts_dict.keys():
            counts_dict[entry] += 1
        else:
            counts_dict[entry] = 1

# Print the populated dictionary
print(counts_dict)


>>>Sample

# Define count_entries()
def count_entries(csv_file, c_size,colname):
    """Return a dictionary with counts of
    occurrences as value for each key."""
    
    # Initialize an empty dictionary: counts_dict
    counts_dict = {}

    # Iterate over the file chunk by chunk
    for chunk in pd.read_csv(csv_file, chunksize=c_size):

    # Iterate over the column in DataFrame
        for entry in chunk[colname]:
            if entry in counts_dict.keys():
                counts_dict[entry] += 1
            else:
                counts_dict[entry] = 1
            
    # Return counts_dict
    return counts_dict

# Call count_entries(): result_counts
result_counts = count_entries('tweets.csv',10,'lang')

# Print result_counts
print(result_counts)

>>other topics

1. List comprehensions

https://www.programiz.com/python-programming/list-comprehension

h_letters = [ letter for letter in 'human' ]
print( h_letters)

words=['hello','world']

result=[word for word in words]
print(result)

letters = list(map(lambda x: x, 'human'))
print(letters)


matrix = [[1, 2], [3,4], [5,6], [7,9]]
transpose = [[row[i] for row in matrix] for i in range(2)]
print (transpose)

2. Dict comprehensions
3. Generators

https://realpython.com/introduction-to-python-generators/

generator functions are a special kind of function that return a lazy iterator


>>>>Functions

str

x=str(5)
print(x)

def square():  #function header
	new_value=4**2
	print(new_value)






